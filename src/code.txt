int xincrement =0;
    int screencount = 0;
    double numbuffer =0.0;
    double decimalplace = 0.1;
    bool decimalfound = false;
    char equationbuffer[MAXBUFFER];
    tft.drawRect(0, 15, 160, 1, ST7735_WHITE);
    tft.drawRect(0, 30, 160, 1, ST7735_WHITE);
    delay(100);
    bool calcresult;
    CALCSTACK calc;
  
    while (true) {
      char key = ButtonLoop();
      if (isdigit(key)) {
        if (decimalfound){
          numbuffer  += (key - '0')*decimalplace;
          decimalplace *= 0.1;
        }else{
          numbuffer = numbuffer* 10 + (key - '0'); // Convert char to int
        }
      } else if (calc.isOperator(key)) {
         if (numbuffer != 0 || key == '-' ) {  // Include negative numbers (e.g., -5)
          calc.pushNumber(numbuffer);
        }
        decimalfound = false;
        decimalplace = 0.1;
        calc.pushOperator(key);
        numbuffer = 0.0; // Reset the buffer for the next number
      }else if (key == '.'){
        decimalfound = true;
      } else if (key == '=') {
                  // Perform evaluation when '=' is pressed
        if (numbuffer != 0) {
          calc.pushNumber(numbuffer); // Push the last number in the buffer
          numbuffer = 0; // Reset the buffer
        }
  
        if (calc.isEmpty() == 1){
          try {
                      calc.evaluate(); // Evaluate the current expression
                      double  result = calc.peekNumber(); // Get the result
                      int accuracy = calc.countDecimalPlaces(result);
                      
                      // Display the result on the screen
                      tft.drawRect(0, 30, 160, 1, ST7735_BLACK);
                      tft.setCursor(145, 20);
                      tft.print(result,accuracy);
                      calcresult = true;
  
                  } catch (const std::exception& e) {
                      tft.setCursor(100, 30);
                      tft.print("Error: ");
                      tft.print(e.what());
                  }
        }          
      } else if (key == 'O') {
                  // Clear the screen and reset the stack
                  calc = CALCSTACK(); // Reinitialize the stack
                  calcresult= false;
                  xincrement = 0;
                  screencount = 0;
                  tft.fillScreen(ST7735_WHITE); // Clear the TFT display
                  tft.setCursor(0, 15);
      }
      if(key!= 'z' && calcresult == false){
        delay(500);
        if (screencount <= 22 ){
            tft.setCursor(xincrement,5);
            tft.setTextSize(1);
            tft.setTextColor(ST7735_BLACK,ST7735_WHITE);
            if(key!= '='&& key!='O'&& key!='B'){
              tft.print(key);
              xincrement+=7;
              screencount++;
              Serial.println(screencount);
            }
           if (key == 'B') { // Handle backspace
            if (  screencount > 0){
              screencount--; // Decrement screen count
              Serial.println(screencount);
              tft.setCursor(xincrement-7, 5);
              tft.setTextSize(1);
              tft.setTextColor(ST7735_BLACK, ST7735_WHITE);
              tft.print(" "); // Clear the character on display
              xincrement -= 7; // Move cursor back
            }
          // Adjust numbuffer
          if (decimalfound) {
              // Remove the last decimal digit
              decimalplace *= 10; // Reverse the last decimal multiplier
              numbuffer = round(numbuffer * 10.0) / 10.0; // Strip last decimal
          } else {
              // Remove the last integer digit
              numbuffer = floor(numbuffer / 10);
          }
      
  } 
          }
        }
      }
}
